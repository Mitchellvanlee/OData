//---------------------------------------------------------------------
// <copyright file="RandomStrategyFromCategory.cs" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using System.Globalization;

namespace Microsoft.SqlServer.Test.TestShell.Core.InputSpaceModeling
{
	/// <summary>
	/// A random exploration strategy that wraps a <see cref="Category&lt;T&gt;"/> object and just returns one 
	/// (or a fixed number of) value(s) from that category every time.
	/// </summary>
	/// <typeparam name="T">The type of values being returned.</typeparam>
	/// <remarks>
	/// Having
	/// <code><![CDATA[
	/// new RandomStrategyFromCategory<int>(new PointCategory<int>("X", 5, 10), 2)
	/// ]]></code>
	/// is similar to having
	/// <code><![CDATA[
	/// new CategoricalStrategy<int>(new PointCategory<int>("X", 5, 10), new PointCategory<int>("X", 5, 10))
	/// ]]></code>
	/// except for one important subtle difference: in the case of using <see cref="CategoricalStrategy&lt;T&gt;"/>,
	/// the two categories obtained are equivalent, so they'll be considered redundant by Test Shell and only one value
	/// will be used. In contrast, the two values from <see cref="RandomStrategyFromCategory&lt;T&gt;"/> will be considered
	/// different and they will both be used by Shell.
	/// </remarks>
	public class RandomStrategyFromCategory<T> : ExplorationStrategy<T>
	{
		private readonly Category<T> _wrappedCategory;
		private readonly int _numberOfValuesToReturn;

		// I need to create a new thin-wrapper ValueFactory class over the category rather than just using the
		// wrapped category as my value factory to keep the Equals semantics such that any two value factories
		// generated by this strategy will not be equal.
		private class ValueFactory : IValueFactory<T>
		{
			private readonly RandomStrategyFromCategory<T> _parent;

			public ValueFactory(RandomStrategyFromCategory<T> parent)
			{
				_parent = parent;
			}

			public T GetValue()
			{
				return _parent.WrappedCategory.GetValue();
			}

			public override string ToString()
			{
				return "Random value from category: " + _parent.WrappedCategory;
			}

			object IValueFactory.GetBaseValue()
			{
				return GetValue();
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="RandomStrategyFromCategory&lt;T&gt;"/> class.
		/// </summary>
		/// <param name="wrappedCategory">The wrapped category.</param>
		/// <exception cref="ArgumentNullException"><paramref name="wrappedCategory"/> is <c>null</c>.</exception>
		public RandomStrategyFromCategory(Category<T> wrappedCategory)
			: this(wrappedCategory, 1)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="RandomStrategyFromCategory&lt;T&gt;"/> class.
		/// </summary>
		/// <param name="wrappedCategory">The wrapped category.</param>
		/// <param name="numberOfValuesToReturn">The fixed number of random values to return each time (deafult is 1).</param>
		/// <exception cref="ArgumentNullException"><paramref name="wrappedCategory"/> is <c>null</c>.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="numberOfValuesToReturn"/> is less than 1.</exception>
		public RandomStrategyFromCategory(Category<T> wrappedCategory, int numberOfValuesToReturn)
		{
			if (wrappedCategory == null)
			{
				throw new ArgumentNullException("wrappedCategory");
			}
			if (numberOfValuesToReturn < 1)
			{
				throw new ArgumentOutOfRangeException("numberOfValuesToReturn", "numberOfValuesToReturn should be a positive number.");
			}
			_numberOfValuesToReturn = numberOfValuesToReturn;
			_wrappedCategory = wrappedCategory;
		}

		/// <summary>
		/// Gets the wrapped category.
		/// </summary>
		/// <value>The wrapped category.</value>
		public Category<T> WrappedCategory
		{
			get { return _wrappedCategory; }
		}

		/// <summary>
		/// Gets the number of values to return.
		/// </summary>
		/// <value>The number of values to return.</value>
		public int NumberOfValuesToReturn
		{
			get { return _numberOfValuesToReturn; }
		} 

		/// <summary>
		/// Explores the input (sub-)space to give (potentially dynamic) value factories. Each invocation may return a different set.
		/// </summary>
		/// <returns>
		/// A (reasonably-sized) stream of vector/value-factories from the (sub-)space.
		/// </returns>
		public override IEnumerable<IValueFactory<T>> DynamicExplore()
		{
			for (int i = 0; i < _numberOfValuesToReturn; i++)
			{
				yield return new ValueFactory(this);
			}
		}

		/// <summary>
		/// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
		/// </summary>
		/// <returns>
		/// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
		/// </returns>
		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "Random strategy ({0}) wrapping the category: {1}",
				_numberOfValuesToReturn, _wrappedCategory);
		}
	}
}
